shiny::runApp()
?tempfile
library(shiny); runApp('C:/Users/Administrator/Desktop/test.R')
install.packages(shinyFiles)
install.packages("C:/Users/Administrator/Desktop/shinyFiles_0.7.2.tar.gz", repos = NULL, type = "source")
library(shinyFiles)
runApp('C:/Users/Administrator/Desktop/test.R')
? getVolumes
?parseFilePaths
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
?observe
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
?reactive
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('E:/GitHub/test/testv222')
runApp('E:/GitHub/test/testv222')
runApp('C:/Users/Administrator/Desktop/test.R')
runApp('C:/Users/Administrator/Desktop/test.R')
?observeEvent
runApp('C:/Users/Administrator/Desktop/Seed-master/Seed-master')
install.packages("C:/Users/Administrator/Desktop/Seed-master.zip", repos = NULL, type = "win.binary")
runApp()
shiny::runApp()
refFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\hg19sub.fa"
indexDir <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\indexFile"
tmp <- bowtie_build(references=refFiles, outdir=indexDir, prefix="index", force=TRUE)
head(tmp)
tail(tmp)
tmp[1]
tmp[2]
indexDir <- tempdir()
bowtie_build(references=refFiles, outdir=indexDir, prefix="index", force=TRUE)
indexDir
bowtie(sequences=readsFiles,
index=file.path(indexDir, "index"),
outfile = samFiles,type = "single",S=TRUE,
f=TRUE, n=0, force=TRUE)
readsFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\probeseq.fa"
bowtie(sequences=readsFiles,
index=file.path(indexDir, "index"),
outfile = samFiles,type = "single",S=TRUE,
f=TRUE, n=0, force=TRUE)
samFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\alignment.sam"
bowtie(sequences=readsFiles,
index=file.path(indexDir, "index"),
outfile = samFiles,type = "single",S=TRUE,
f=TRUE, n=0, force=TRUE)
runApp()
BiocManager::install("Sushi", version = "3.8")
browseVignettes(shushi)
browseVignettes("Shushi")
browseVignettes("sushi")
browseVignettes("Sushi")
runApp()
runApp()
refFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\hg19sub.fa"
indexDir <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\indexFile"
indexDir <- tempdir()
tmp <- bowtie_build(references=refFiles, outdir=indexDir, prefix="index", force=TRUE)
head(tmp)
readsFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\probeseq.fa"
samFiles <- "C:\\Users\\Administrator\\Desktop\\testBowtie\\alignment.sam"
bowtie(sequences=readsFiles,
index=file.path(indexDir, "index"),
outfile = samFiles,type = "single",S=TRUE,
f=TRUE, n=0, force=TRUE)
bamtemp <- tempdir()
bamtemp <- tempdir()
bamFile <- Rsamtools::asBam(file = samFiles, destination = bamtemp, overwrite = T)
bam <- scanBam(bamFile)
tmp=as.data.frame(do.call(cbind,lapply(bam[[1]], as.character)),stringsAsFactors = F)
tmp=tmp[tmp$flag!=4,]
tmp$end=as.numeric(tmp$pos)+as.numeric(tmp$qwidth)
#create .bam GRanges Objects
my_seq <- with(tmp, GRanges(as.character(rname),
IRanges(as.numeric(pos), end),
as.character(strand),
id = as.character(qname)))
my_seq
View(tmp)
plotBed(my_seq)
seqBed <- data.frame(chr = tmp$rname, start = tmp$pos,end=tmp$end)
View(seqBed)
plotBed(seqBed)
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
chrom = "chr1"
chromstart = 241
chromend = 421
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
plotBed(seqBed,chrom = chrom,chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
colorbycol = SushiColors(2),row = "auto",wiggle=0.001)
chrom = "chr1"
chromstart = 1
chromend = 2000
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
plotBed(seqBed,chrom = chrom,chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
colorbycol = SushiColors(2),row = "auto",wiggle=0.001)
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
plotBed(seqBed,chrom = c("chr1","chr2","chr3"),chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
colorbycol = SushiColors(2),row = "auto",wiggle=0.001)
?plotBed
chromstart = 1
chromend = 40000
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
plotBed(seqBed,chrom = c("chr1","chr2","chr3"),chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
# colorbycol = SushiColors(2),
row = "auto",wiggle=0.001)
data(Sushi_ChIPSeq_severalfactors.bed)
chrom            = "chr15"
chromstart      = 72800000
chromend         = 73100000
Sushi_ChIPSeq_severalfactors.bed$color = heat.colors(max(Sushi_ChIPSeq_severalfactors.bed$row))[Sushi_ChIPSeq_severalfactors.bed$row]
plotBed(beddata    = Sushi_ChIPSeq_severalfactors.bed,chrom = chrom,chromstart = chromstart,chromend =chromend,
rownumber  = Sushi_ChIPSeq_severalfactors.bed$row, type = "circles",color=Sushi_ChIPSeq_severalfactors.bed$color,row="given",plotbg="grey95",
rowlabels=unique(Sushi_ChIPSeq_severalfactors.bed$name),rowlabelcol=unique(Sushi_ChIPSeq_severalfactors.bed$color),rowlabelcex=0.75)
Sushi_ChIPSeq_severalfactors.bed$color = heat.colors(max(Sushi_ChIPSeq_severalfactors.bed$row))[Sushi_ChIPSeq_severalfactors.bed$row]
plotBed(beddata    = Sushi_ChIPSeq_severalfactors.bed,chrom = chrom,chromstart = chromstart,chromend =chromend,
rownumber  = Sushi_ChIPSeq_severalfactors.bed$row, type = "region",color=Sushi_ChIPSeq_severalfactors.bed$color,row="given",plotbg="grey95",
rowlabels=unique(Sushi_ChIPSeq_severalfactors.bed$name),rowlabelcol=unique(Sushi_ChIPSeq_severalfactors.bed$color),rowlabelcex=0.75)
colors = c("dodgerblue1","firebrick2","violet","yellow",
"dodgerblue1","firebrick2","violet","yellow",
"dodgerblue1","firebrick2","violet")
plotBed(beddata    = Sushi_ChIPSeq_severalfactors.bed,chrom = chrom,chromstart = chromstart,chromend =chromend,
rownumber  = Sushi_ChIPSeq_severalfactors.bed$row, type = "density",row="supplied",
rowlabels=unique(Sushi_ChIPSeq_severalfactors.bed$name),rowlabelcol=colors,rowlabelcex=0.75,
palettes=list(
colorRampPalette(c("black",colors[1])),
colorRampPalette(c("black",colors[2])),
colorRampPalette(c("black",colors[3])),
colorRampPalette(c("black",colors[4])),
colorRampPalette(c("black",colors[5])),
colorRampPalette(c("black",colors[6])),
colorRampPalette(c("black",colors[7])),
colorRampPalette(c("black",colors[8])),
colorRampPalette(c("black",colors[9])),
colorRampPalette(c("black",colors[10])),
colorRampPalette(c("black",colors[11]))))
chrom = "chr1"
chromstart = 1
chromend = 40000
seqBed <- data.frame(chrom = tmp$rname, start = tmp$pos,end=tmp$end)
plotBed(seqBed,chrom = c("chr1","chr2","chr3"),chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
# colorbycol = SushiColors(2),
row = "auto",wiggle=0.001)
plotBed(seqBed,chrom = c("chr1"),chromstart = chromstart,
chromend =chromend,#colorby = Sushi_ChIPSeq_pol2.bed$strand,
# colorbycol = SushiColors(2),
row = "auto",wiggle=0.001)
shiny::runApp()
runApp()
runApp('C:/Users/Administrator/Desktop/Seed-master/Seed-master')
library(seed)
runApp('C:/Users/Administrator/Desktop/LocusExplorer-master/LocusExplorer-master')
library(shiny)
runGitHub("Seed","danlbek")
shiny::runApp('E:/GitHub/test/newtesttt')
library(seed)
runGitHub("Seed","danlbek")
install.packages("shinythemes")
?tabBox
library(shinydashboard)
?tabBox
f (interactive()) {
library(shiny)
body <- dashboardBody(
fluidRow(
tabBox(
title = "First tabBox",
# The id lets us use input$tabset1 on the server to find the current tab
id = "tabset1", height = "250px",
tabPanel("Tab1", "First tab content"),
tabPanel("Tab2", "Tab content 2")
),
tabBox(
side = "right", height = "250px",
selected = "Tab3",
tabPanel("Tab1", "Tab content 1"),
tabPanel("Tab2", "Tab content 2"),
tabPanel("Tab3", "Note that when side=right, the tab order is reversed.")
)
),
fluidRow(
tabBox(
# Title can include an icon
title = tagList(shiny::icon("gear"), "tabBox status"),
tabPanel("Tab1",
"Currently selected tab from first box:",
verbatimTextOutput("tabset1Selected")
),
tabPanel("Tab2", "Tab content 2")
)
)
)
shinyApp(
ui = dashboardPage(dashboardHeader(title = "tabBoxes"), dashboardSidebar(), body),
server = function(input, output) {
# The currently selected tab from the first box
output$tabset1Selected <- renderText({
input$tabset1
})
}
)
?pageWithSidebar
pageWithSidebar(
# Application title
headerPanel("Hello Shiny!"),
# Sidebar with a slider input
sidebarPanel(
sliderInput("obs",
"Number of observations:",
min = 0,
max = 1000,
value = 500)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
runApp()
shiny::runGist("c4db11d81f3c46a7c4a5")
library(shiny)
shiny::runGist("c4db11d81f3c46a7c4a5")
library(shiny)
# Define the fields we want to save from the form
fields <- c("name", "used_shiny", "r_num_years")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
DT::dataTableOutput("responses", width = 300), tags$hr(),
textInput("name", "Name", ""),
checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
sliderInput("r_num_years", "Number of years using R",
0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- DT::renderDataTable({
input$submit
loadData()
})
}
)
runApp('E:/GitHub/Demo/Rscripts/shinyApp_Test/storageData_shinyApp.R')
?exists
runApp('E:/GitHub/Demo/Rscripts/shinyApp_Test/storageData_shinyApp.R')
runApp()
library(knitr)
install.pacakges("formatR")
install.packages("formatR")
library(formatR)
formatR::tidy_dir("R")
formatR::tidy_dir("R")
install.packages("dbplyr")
?tags
runApp()
runApp()
runApp()
?updateSelectizeInput
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
formatR::tidy_dir("E:\\GitHub\\Demo\\IDmapApp\\IDmap\\")
shiny::runApp('C:/Users/Administrator/Desktop/TF_map-master/TF_map-master')
install.pc
install.packages("shinyBS")
runApp()
?icon
runApp()
runApp()
?observeEvent
?runif
u <- runif(20)
u
?eventReactive
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
gplname = read.xlsx("data\\gpl_list.xlsx")
as.vector(gplname[,1])
runApp()
runApp()
runApp()
install.packages("RMySQL")
library(RMySQL)
?dbSendQuery
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "mtcars", mtcars)
rs <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)
# Pass one set of values with the param argument:
rs <- dbSendQuery(
con,
"SELECT * FROM mtcars WHERE cyl = ?",
param = list(4L)
)
dbFetch(rs)
dbClearResult(rs)
# Pass multiple sets of values with dbBind():
rs <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = ?")
dbBind(rs, list(6L))
dbFetch(rs)
dbBind(rs, list(8L))
dbFetch(rs)
dbClearResult(rs)
dbDisconnect(con)
?dbGetQuery
host <<- "127.0.0.1"
port <<- 3306
user <<- "idmapuser"
password <<-  'idmap123'
library(RMySQL)
db <- dbConnect(RMySQL::MySQL(), host=host, port=port, user=user, password=password)
host <<- "localhost"
port <<- 3306
user <<- "idmapuser"
password <<-  'idmap123'
library(RMySQL)
db <- dbConnect(RMySQL::MySQL(), host=host, port=port, user=user, password=password)
?dbConnect
host <<- "localhost"
port <<- 3306
user <<- "idmapuser"
password <<-  'idmap123'
library(RMySQL)
db <- dbConnect(RMySQL::MySQL(), host=host,dbname="idmapDB",port=port, user=user, password=password)
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
server <- function(input, output) {
output$plot <- renderPlot({
input$goPlot # Re-run when button is clicked
# Create 0-row data frame which will be used to store data
dat <- data.frame(x = numeric(0), y = numeric(0))
withProgress(message = 'Making plot', value = 0, {
# Number of times we'll go through the loop
n <- 10
for (i in 1:n) {
# Each time through the loop, add another row of data. This is
# a stand-in for a long-running computation.
dat <- rbind(dat, data.frame(x = rnorm(1), y = rnorm(1)))
# Increment the progress bar, and update the detail text.
incProgress(1/n, detail = paste("Doing part", i))
# Pause for 0.1 seconds to simulate a long computation.
Sys.sleep(0.1)
}
})
plot(dat$x, dat$y)
})
}
ui <- shinyUI(basicPage(
plotOutput('plot', width = "300px", height = "300px"),
actionButton('goPlot', 'Go plot')
))
shinyApp(ui = ui, server = server)
# This function computes a new data set. It can optionally take a function,
# updateProgress, which will be called as each row of data is added.
compute_data <- function(updateProgress = NULL) {
# Create 0-row data frame which will be used to store data
dat <- data.frame(x = numeric(0), y = numeric(0))
for (i in 1:10) {
Sys.sleep(0.25)
# Compute new row of data
new_row <- data.frame(x = rnorm(1), y = rnorm(1))
# If we were passed a progress update function, call it
if (is.function(updateProgress)) {
text <- paste0("x:", round(new_row$x, 2), " y:", round(new_row$y, 2))
updateProgress(detail = text)
}
# Add the new row of data
dat <- rbind(dat, new_row)
}
dat
}
server <- function(input, output) {
output$table <- renderTable({
input$goTable
# Create a Progress object
progress <- shiny::Progress$new()
progress$set(message = "Computing data", value = 0)
# Close the progress when this reactive exits (even if there's an error)
on.exit(progress$close())
# Create a callback function to update progress.
# Each time this is called:
# - If `value` is NULL, it will move the progress bar 1/5 of the remaining
#   distance. If non-NULL, it will set the progress to that value.
# - It also accepts optional detail text.
updateProgress <- function(value = NULL, detail = NULL) {
if (is.null(value)) {
value <- progress$getValue()
value <- value + (progress$getMax() - value) / 5
}
progress$set(value = value, detail = detail)
}
# Compute the new data, and pass in the updateProgress function so
# that it can update the progress indicator.
compute_data(updateProgress)
})
}
ui <- shinyUI(basicPage(
tableOutput('table'),
actionButton('goTable', 'Go table')
))
shinyApp(ui = ui, server = server)
runApp()
runApp()
runApp()
